# Sorting Algorithm Analysis
This set of java classes contains implementations of 5 different sortings algorithms which then run the same 5 integer arrays (generated randomly in the case of target1, target2 and targetBig and constructed in the cases of target3 and target4) to demonstrate that they work properly, as well  as providing the number of iterations (steps taken to analyse each element of array) and operations (number of actual integer swaps necessary to sort each array.) 

To maintain cohesiveness of thought, please read the classes in the following order: bubble, insertion, selection, quick, and finally merge. Within each class are more detailed comments upon the efficiency and runtime complexity of each algorithm, defining the worst case efficiency in O(n) notation (Quick sort does discuss the average Î¸(n) notation as it is relevant to the algorithm's value*,) and situations in which the various algorithms shine.

The reason this work has value and why it is important for my learning (and that of any aspiring student of computer science) is because efficiency is regarded as a positive attribute for any system, (unless, I suppose, you happen to be an anarcho-primitivist.) In real world examples, sifting through mountains of data and the speed that takes has a direct correlation to productivity generated by one's work and thus one's value to their employer and community. Actually implementing these various algorithms allows one to learn by simply doing, and to gain a deeper understanding thereof by viewing the algorithm one has just constructed in action and manipulating it to produce various results. To conclude, this informative analysis has deepened my understanding of an abstract concept like program runtime by showing a concrete example thereof.

*The average runtime complexity of the quick sort in question will not be derived as the math required is exhaustive and has already been solved by various authorities.
