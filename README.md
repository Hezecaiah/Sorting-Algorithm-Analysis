# Sorting-Algortithm-Analysis
This set of java classes contains implementations of 5 different sortings algorithms which then run the same 5 integer arrays
(generated randomly in the case of target1, target2 and targetBig and constructed in the cases of target3 and target4) to demonstrate
that they work properly, as well  as providing the number of iterations (steps taken to analyse each element of array) and operations
(number of actual integer swaps necessary to sort each array.) 

To maintain cohesiveness of thought, please read the classes in the following order: bubble, insertion, selection, quick, and finally
merge. Within each class are more detailed comments upon the efficiency and runtime complexity of each algorithm, defining the worst case 
efficiency in O(n) notation (Quick sort does discuss the average Î¸(n) notation as it is relevant to the algorithm's value*,) and
situations in which the various algorithms shine.

The reason this work has value and why it is important for my learning (and that of any aspiring student of computer science) is
because efficiency is regarded as a positive attribute for any system, (unless, I suppose, you happen to be an 
anarcho-primitivist.) In real world examples, sifting through mountains of data and the speed that takes has a direct correlation to
productivity generated by one's work and thus one's value to their employer and community.
